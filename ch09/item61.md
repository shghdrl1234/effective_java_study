# item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

## 박싱된 기본 타입이란

Integer, Long, Double 등 기본 타입에 대응하는 참조 타입을 박싱된 기본 타입이라고 함

**자바의 데이터 타입 2가지**

- 기본 타입: int, long, double 등
- 참조 타입: String, List 등

## 기본 타입 vs 박싱된 기본 타입

1. 기본 타입은 값만 가지고 있지만 박싱된 기본 타입은 값과 식별성을 가짐
2. 기본 타입의 값은 항상 유효하지만 박싱된 기본 타입은 null을 가질 수 있음
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 측면에서 효율적

   → 세 가지 차이점 때문에 주의하지 않으면 문제나 성능 이슈가 생길 수 있다

### 타입과 참조 타입을 혼용한 예시(1)
다음과 같이 Integer 값을 오름차순으로 정렬하는 비교자를 가정해보자.

```java
Comparator<Integer> naturalOrder =
  (i, j) -> (i < j) ? -1 : (i = j ? 0 : 1);
  
naturalOrder.compare(new Integer(42), new Integer(42)) // 1 출력
```

두 `Integer` 객체를 비교했을때, 숫자의 값이 같아서 **0을 반환해야 할텐데 1 을 반환하는 이유**는 무엇일까?

- 첫 번째 `i < j` 에서 오토박싱된 Integer 인스턴스는 기본 타입을 변환되고 값이 작은지 평가한다. 
- 하지만 두번째 `i = j` 에서는 `객체 참조의 식별성`을 검사하게 된다.
- 즉 내용 기준이 아닌 객체의 주소값을 기준으로 비교하게 되고, 서로 다른 Integer 인스턴스라면 1을 반환하게 되는 것이다.

> 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.

#### 해결
```java
Comparator<Ineteger> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;  // 오토 박싱
    return i < j ? -1 : (i == j ? 0 : 1);
```
오토박싱으로 검사 전에 바꾸어서 식별성 검사가 이루어지지 않게 하는 방법이다.

### 타입과 참조 타입을 혼용한 예시(2)
```java
public cass Unbelievable {
	static Integer i;  // 예외 발생!
    
    public static void main(String[] args){
    	if (i == 42)
        	System.out.println("믿을 수 없군!");
    }
}
```
**`i == 42` 를 검사할때 `NullPointerException` 을 던지는 기이한 결과**

- 원인은, Integer가 다른 참조 타입 필드와 마찬가지로 초기값이 `null`이기 때문이다.
- 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 
- 따라서 null 참조를 언박싱하게 되면 NullPointerException이 발생하는 것이다.

#### 해결
`i`를 `int`로 선언해주자

### 타입과 참조 타입을 혼용한 예시(3)
```java
public static void main(String[] args) {
	Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    	sum += i;
    }
    System.out.println(sum);
}
```
- 이 프로그램은 지역변수 `sum` 을 박싱된 기본 타입으로 선언하여 **매우 느린 성능**을 보여준다.
- 오류나 경고 없이 컴파일되지만, **박싱과 언박싱이 반복**해서 일어나고 있기 때문이다.

## 박싱타입은 언제 사용해야 할까
1. 컬렉션의 원소, 키, 값으로 사용할 때
    - 사실 이부분은 컬렉션을 사용할때 어쩔수 없이 기본타입을 사용하지 못하기 때문이다
2. 제네릭을 사용할때
    - 제네릭에서도 기본타입을 지원하지 않기 때문이다
3. 리플렉션을 통해 메서드를 호출할 때

## 결론
- 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 위험까지 없애주지 않는다.
- 언방식 과정에서 NullPointerException 발생할 확률이 있다.
- 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 성능적으로 부작용을 일으킬수도 있다.
