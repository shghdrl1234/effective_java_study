# Item 19
## 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속을 고려한 설계와 문서화란?
  - 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다
  - 어떤 순서로 호출하는지, 호출결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다
  - 더 넓게는 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다
  

```java
public boolean remove(Object o)

주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스르 하나 제거한다(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에
'Object.equals(o, e)가 참인 원소' e가 하나 이상 있다면 그 중 하나를 제거한다.
 (... 중략)
Implementaion Requirements : 이 메서드는 컬렉션을 순회하며 주어진 원솔르 찾도록 구현되었다. 주어진 원소를 찾으면
반복자의 remove 메서드를 사용해 컬렉션에서 제거한다.
 (... 생략)

// (위와 같이 API 문서를 보면 종종 Implementaion Requirements로 시작하는 절을 볼 수 있는데 메서드의 내부 동작방식을
// 설명하는 곳, 메서드 주석에 @implSplec 태그를 붙여주면 자바독 도구가 생성해준다)
```



 <br>

- "좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다"
  - 상속이 캡슐화를 해치기 때문에 일어나는 현실 (어쩔 수 없이 내부 구현 방식을 설명해야 한다)
 
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스 내부 동작에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개할 수도 있다.
  - 어떤 메서드를 protected로 노출할지는 정해져 있지 않다. 심사숙고해서 잘 예측하고 실제 하위 클래스를 만들어 시험해보는 것이 최선
  - 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다.
  - 따라서 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어서 검증해야 한다.

<br>
 
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
  - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.

```java
// 상위 클래스
public class Super {
  // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
  public Super() {
    overrideMe();
  }

  public void overrideMe() {
  }
}

// overrideMe 메서드를 재정의 한 하위 클래스
public final class Sub extends Super {
  // 초기화되지 않은 final 필드, 생성자에서 초기화한다.
  private final Instant instant;

  Sub() {
    instant = Instant.now();
  }

  // 재정의 가능 메서드, 상위 클래스의 생성자가 호출한다
  @Override
  public void overrideMe() {
    System.out.println(instant);
  }

  public static void main(String[] args) {
    Sub sub = new Sub();
    Sub.overrideMe();
  }

}
// 위 코드의 실행 결과는?
```

<br>

- Cloneable과 Serializable 상속용 설계의 예시
  - 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다

- 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 좋다
  - 클래스를 final로 선언하는 방법
  - 모든 생성자를 private으로 선언하고 public 정적 팩토리를 만들어주는 방법

- 클래스의 동작을 유 지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법
  - 각각의 재정의 가능 메서드는 자신의 본문 코드를 private '도우미 메서드'에 옮기고, 도우미 메서드를 호출하도록 수정
  - 그 후 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정

<br>

```
# 핵심!

 상속용 클래스를 설계하기는 어렵다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며,
일단 문서화 한 것은 클래스가 써이는 한 반드시 지켜야 한다. 다른 이가 효율적인 하위 클래스를 만들 수 있도록 일부를
protected로 제공할 수도 있다.
그러니 클래스를 확장해야 할 명확한 이유가 없다면 상속을 금지하는 편이 낫다. 상속을 금지하려면 클래스를 final로 선언하거나
생성자 모두를 외부에서 접근할 수 없도록 만들면 된다
```
