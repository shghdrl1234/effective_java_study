item 15. 클래스와 멤버의 접근을 최소화하라
=============

잘 설계된 컴포넌트
-
클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼는가?
> 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 됨

- 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리
- 오직 API를 통해서만 다른 컴포넌트와 소통
- 서로의 내부 동작 방식에는 전혀 개의치 않음


정보 은닉의 장점
- 
- 시스템 개발 속도를 높인다
- 시스템 관리 비용을 낮춘다
- 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다
- 소프트웨어 재사용성을 높인다
- 큰 시스템을 제작하는 난이도를 낮춰준다


### 자바의 정보 은닉
다양한 장치를 제공하지만, 그중 **접근 제어 메커니즘**은 **클래스**, **인터페이스**, **멤버의 접근성**(접근 허용 범위)을 명시한다.
각 요소의 접근성은 그 요소가 **선언된 위치**와 **접근 제한자**로 정해진다.    


접근 제한자 활용
-
- 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준은 4가지다.
    1. **private** : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
    2. **package-private** : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을때 적용되는 패키지 접근 수준이다.(단, 인터페이스의 멤버는 기본적으로 public)
    3. **protected** : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
    4. **public** : 모든 곳에서 접근할 수 있다.


### 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.
소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야함

톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준
- package-private
- public

package-private으로 선언하면 해당 패키지 안에서만 이용   
public으로 선언하면 공개 API가 됨


### 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하자.
클라이언트에 아무런 피해 없이 다음 릴리스에서 수정, 교체, 제거 가능.    
반면, **public으로 선언하면 API**가 되므로 하위 호환을 위해 영원히 관리해줘야함


### private static으로 중첩시키자.
- 톱레벨로 두면 같은 패키지의 모든 클래스가 접근할 수 있지만, private static으로 중첩시키면 **바깥 클래스 하나에서만 접근**할 수 있다.
- 더 중요한 것은 public일 필요 없는 클래스 접근 수준을 package-private 톱레벨 클래스로 좁히는 일이다.
  * public 클래스는 그 패키지 API인 반면, package-private 톱레벨 클래스는 내부 구현에 속하기 때문이다. 

### 클래스의 공개 API 설계 후, 그 외의 모든 멤버는 private으로 만들자.
- 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 packagae-private으로 풀어주자.
- 이때, 권한을 풀어주는 일이 자주 발생하면, 시스템에서 컴포넌트를 더 분해해야 하는 것은 아닌지 다시 고민해야함.
- private과 package-priavte 멤버는 모두 해당 클래스의 구현에 해당하므로 보통은 공개 API에 영향을 주지 않는다(단, Serializable 구현에서는 제외)
- protected 멤버의 수는 적을 수록 좋다 -> public클래스의 protected 멤버는 공개 API 이므로..

### 상위 클래스의 메서드를 재정의 할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.
> 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다(리스코프 치환 원칙, item 10)

단, 클래스가 인터페이스를 구현하는 것은 예외   
이때 클래스는 인터페이스가 정의한 모든 메서드를 public으로 선언해야함


## 주의 사항
1. 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다.
   * 테스트 코드를 테스트 대상과 같은 패키지에 두면 package-private요소에 접근할 수 있기 때문
2. public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
    * 필드가 가변 객체를 참고하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 **불변식을 보장 할 수 없음**
        * public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
        * 내부 구현을 바꾸고 싶어도 그 public 필드를 없애는 방식으로 리팩터리 할 수 없게 된다.
    * 예외로, 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다.
    * 길이가 0이 아닌 배열은 모두 변경 가능하니 주의하자.   
      따라서 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.
      * 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있음
      ```java
      // 보안 허점이 숨어 있다.
        public static fianl Ting[] VALUES = { ... };
      ``` 
      VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경할 수 있다.
      * 해결 방법 1 : 앞 코드의 public 배열을 private로 만들고 public 불변 리스트를 추가한다.
      ```java
      private static final Thing[] PRIVATE_VALUES = { ... }; 
      public static final List<Thing> VALUES = 
            Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
      ```
      * 해결 방법 2 : 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가한다.(방어적 복사)
      ```java
      private static final Thing[] PRIVATE_VALUES = { ... };
      public static fianl Thing[] values() {
            return PRIVATE_VALUES.clone();
      }
      ```
      
핵심정리
-
* 프로그램 요소의 접근성은 가능한 최소한으로 해야한다. 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
* public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다.
* public static final 필드가 참조하는 객체가 불변인지 확인하라.
